# 万亿多边形的秘密：Nanite 与虚拟几何体革命

> 当影视级模型（数百万三角形）可以直接拖入游戏引擎而不需要手动减面——这就是 Nanite 带来的革命。本文从传统 LOD 到虚拟几何体，全面解析几何处理技术的前世今生。

## 引言：美术师的永恒之痛

在 Nanite 之前，游戏开发中存在一条痛苦的"资产管线"：

```
影视级高模（500万三角形）
    ↓ 手工减面（Retopology）
游戏级中模（50,000三角形）
    ↓ 手工制作 LOD 层级
LOD0（50K）→ LOD1（10K）→ LOD2（2K）→ LOD3（500）→ Billboard
    ↓ 烘焙法线贴图
将高模细节烘焙到低模的法线贴图上
```

这个过程耗时、昂贵、容易出错，是整个游戏开发管线中最大的瓶颈之一。

**Nanite 的承诺**：直接导入影视级资产，引擎自动处理一切细节层次，永远只渲染"刚好够"的三角形。

---

## 传统 LOD 系统

### 离散 LOD（Discrete LOD）

最经典的 LOD 方案——为每个模型预制 3-5 个精度等级：

| 距离 | LOD 等级 | 三角形数 | 视觉表现 |
|------|---------|---------|---------|
| 0-10m | LOD0 | 50,000 | 全细节 |
| 10-30m | LOD1 | 10,000 | 大部分细节 |
| 30-80m | LOD2 | 2,000 | 轮廓保持 |
| 80-200m | LOD3 | 500 | 远景轮廓 |
| >200m | Billboard | 2 | 纹理贴片 |

**核心问题**：

1. **LOD 切换跳变（Popping）**：当物体在两个 LOD 等级之间切换时，画面会出现明显的突变
2. **手工制作成本**：每个 LOD 等级都需要美术师手动或半自动生成
3. **粒度太粗**：整个模型统一切换，无法对一个模型的不同部分使用不同精度
4. **不考虑遮挡**：即使模型的背面不可见，仍然渲染完整的 LOD 等级

### 连续 LOD（CLOD）与渐进网格

1996 年 Hugues Hoppe 提出了**渐进网格（Progressive Meshes）**——通过边折叠（Edge Collapse）操作，可以从高模连续简化到低模：

$$\text{高模} \xrightarrow{\text{折叠边}_1} \text{稍低模} \xrightarrow{\text{折叠边}_2} \cdots \xrightarrow{\text{折叠边}_n} \text{低模}$$

理论上，每个边折叠可以逆向恢复（顶点分裂），因此一个模型可以在任意精度等级之间连续过渡。

但传统 CLOD 在实践中没有广泛使用——因为每次精度调整都需要修改索引缓冲，对 GPU 的数据流不友好。

---

## 虚拟纹理（Virtual Texturing）

在理解 Nanite 之前，先了解**虚拟纹理**的思想——Nanite 的理念本质上是"虚拟纹理在几何域的推广"。

### Megatexture（id Tech 5, 2011）

John Carmack 在《Rage》中引入了一个大胆的想法：整个关卡使用**一张巨大的纹理**（可达 128K×128K），运行时按需加载可见的小块（Tile）。

```
虚拟纹理：
  逻辑上：一张 128K × 128K 的超大纹理
  物理上：只在显存中保留当前可见的 Tile
  
  当摄像机移动时：
  → 计算新的可见 Tile
  → 从磁盘流式加载
  → 替换不再需要的 Tile
```

**虚拟纹理 = 纹理的"虚拟内存"**——就像操作系统的虚拟内存让每个程序认为自己有无限内存一样，虚拟纹理让渲染器认为自己有一张无限大的纹理。

### 从虚拟纹理到虚拟几何体

Nanite 将这个思想从纹理域推广到了几何域：

```
虚拟几何体（Nanite）：
  逻辑上：每个模型有无限精度的三角形
  物理上：只在 GPU 内存中保留当前可见的、当前精度需要的三角形簇
  
  当摄像机移动时：
  → 根据屏幕投影大小决定每个区域需要的精度
  → 流式加载/释放三角形数据
  → 永远只处理"刚好够"的三角形
```

---

## Nanite 深度解析

### 核心数据结构：簇层次（Cluster Hierarchy）

Nanite 将每个模型组织为一棵**簇树（Cluster Tree）**：

```
根节点（最粗糙的表示）
├── 子簇 1（中等精度）
│   ├── 叶簇 1a（全精度，~128 三角形）
│   ├── 叶簇 1b
│   └── ...
├── 子簇 2
│   └── ...
└── ...
```

每个**簇（Cluster）** 包含约 128 个三角形——这个大小经过精心选择，使其既能适配 GPU 的工作组大小，又能提供足够细粒度的 LOD 控制。

关键特性：
- **每个簇独立决定 LOD 等级**——同一个模型上，面向摄像机的部分可以是高精度，远离的部分可以是低精度
- **无缝过渡**——相邻簇之间通过特殊的边界锁定避免裂缝
- **基于误差度量的选择**——对每个簇计算其在屏幕空间的误差，保证误差不超过 1 像素

### 可见性判断：两阶段剔除

Nanite 使用精密的两阶段剔除来最小化需要处理的簇数量：

```
阶段 1: 粗粒度剔除（GPU Instance Culling）
  → 视锥剔除
  → Hi-Z 遮挡剔除（使用上一帧的深度缓冲）
  → 排除完全不可见的实例

阶段 2: 细粒度簇剔除（Per-Cluster Culling）
  → 每个可见实例内部的簇级别剔除
  → 基于屏幕误差选择 LOD 等级
  → 背面剔除
```

### 软件光栅化：为什么不用硬件？

Nanite 最令人惊讶的设计决策之一是：**对小三角形使用软件光栅化**。

原因是现代 GPU 的硬件光栅化器对**亚像素三角形（小于一个像素的三角形）** 效率极低。当三角形投影到屏幕后小于约 2×2 像素时：

- 硬件光栅化仍然按 2×2 的 Quad 处理（浪费 75% 的线程）
- 三角形设置的固定开销变成主要瓶颈

Nanite 的解决方案：

```
大三角形（>2×2 像素）→ 硬件光栅化（利用固定功能硬件的高效性）
小三角形（<2×2 像素）→ 软件光栅化（Compute Shader，避免 Quad 浪费）
```

软件光栅化通过 Compute Shader 实现，每个线程处理一个三角形，直接写入 Visibility Buffer——没有 Quad 的浪费，效率对小三角形反而更高。

### Visibility Buffer 架构

传统的延迟渲染使用 **G-Buffer**（存储材质属性）。Nanite 使用更高效的 **Visibility Buffer**：

```
传统 G-Buffer（每像素存储）：
  • 法线（16 bytes）
  • 基色（4 bytes）
  • 粗糙度/金属度（4 bytes）
  • 深度（4 bytes）
  → 每像素 ~28 bytes

Visibility Buffer（每像素存储）：
  • 实例 ID（4 bytes）
  • 三角形 ID（4 bytes）
  → 每像素 ~8 bytes
  → 材质属性在后续 Pass 中按需重新计算
```

Visibility Buffer 的带宽开销仅为 G-Buffer 的约 **1/3**，这在高分辨率下优势巨大。

---

## Mesh Shader：几何管线的现代化

### 传统管线的瓶颈

传统的顶点处理管线（VS → HS → DS → GS）是**固定的、串行的**：

- 输入缓冲格式固定
- 无法在管线内部动态增删三角形（几何着色器可以但效率极差）
- 无法进行管线内剔除

### Task Shader + Mesh Shader

DirectX 12 Ultimate 和 Vulkan 引入的新管线模型：

```
传统管线：
  Input Assembly → VS → [HS → Tess → DS] → [GS] → Rasterizer

Mesh Shader 管线：
  Task Shader → Mesh Shader → Rasterizer
```

**Task Shader**（也叫 Amplification Shader）：
- 决定发射多少个 Mesh Shader 工作组
- 可以做 LOD 选择、剔除、工作量动态调整

**Mesh Shader**：
- 类似 Compute Shader 的自由度
- 输出三角形列表（最多 256 个顶点 + 256 个三角形）
- 可以从任意数据源读取几何数据

### Mesh Shader 在 Nanite 中的角色

在支持 Mesh Shader 的硬件上，Nanite 使用它来：
1. Task Shader 完成簇级别的 LOD 选择和剔除
2. Mesh Shader 读取压缩的簇数据，解压并输出三角形
3. 大三角形走硬件光栅化，小三角形走 Compute Shader 软件光栅化

---

## 其他引擎的几何方案

### Unity 的 SpeedTree + LOD 系统

Unity 仍然使用传统的离散 LOD + LOD Cross-Fade（淡入淡出过渡）。SpeedTree 中间件提供了优秀的植被 LOD 自动生成。

Unity 6 引入了 GPU Resident Drawer，将更多的剔除和绘制决策移交 GPU，但没有 Nanite 级别的虚拟几何体系统。

### id Software 的几何方案

id Tech 7（《毁灭战士：永恒》）使用**虚拟纹理 + 传统 LOD**，但极致优化了 Draw Call 和状态切换，在简洁的管线上达到了极高的帧率。

### Guerrilla 的 Decima 引擎

《地平线》系列使用了精细的 LOD 系统 + GPU 驱动的实例剔除，针对开放世界的海量植被和地形进行了专门优化。

---

## 曲面细分 vs Nanite

这两种技术代表了增加几何复杂度的两种不同哲学：

| 维度 | 曲面细分 | Nanite |
|------|---------|--------|
| **数据来源** | 低模 + 位移贴图 | 高模直接导入 |
| **三角形生成** | GPU 实时生成 | 预处理为簇层次 |
| **LOD 粒度** | 每 Patch（补丁） | 每 Cluster（簇） |
| **内存占用** | 低（只存低模+贴图） | 高（存储完整簇层次） |
| **美术工作流** | 需要制作位移贴图 | 直接使用 ZBrush 高模 |
| **适用场景** | 地形、水面 | 通用静态网格 |

两者并非互斥——UE5 中地形仍然使用曲面细分（Virtual Heightfield Mesh），而静态资产使用 Nanite。

---

## 前沿研究

### 实时网格简化

学术界正在研究更高效的实时网格简化算法，使得动态物体（如角色、可破坏环境）也能享受 Nanite 级别的自动 LOD。

### Neural Geometry（神经几何）

用神经网络学习几何的隐式表示（如 Neural SDF），在推理时动态生成任意精度的几何体。这是将 AI 引入几何管线的前沿方向。

### 程序化几何

结合程序化生成和虚拟几何体——不存储三角形数据，而是存储生成规则，在 GPU 上实时生成所需精度的几何体。

---

## 小结

| 技术 | 时代 | 核心思想 |
|------|------|---------|
| 离散 LOD | 2000s | 手工制作多精度模型 |
| 渐进网格 | 1996 | 边折叠实现连续精度 |
| 虚拟纹理 | 2011 | 按需流式加载纹理块 |
| 曲面细分 | 2009 | GPU 实时生成细分几何 |
| Mesh Shader | 2018 | 可编程的灵活几何管线 |
| **Nanite** | **2022** | **虚拟几何体——按像素误差自动 LOD** |

Nanite 代表了几何处理的一次范式转变：从"美术师手动管理精度"到"引擎自动管理精度"。它解放了美术生产力，使得游戏资产可以达到影视级品质。

---

*上一篇：[全局光照的圣杯之战：从光线追踪到 Lumen](./04-全局光照的圣杯之战：从光线追踪到Lumen.md)*

*下一篇：[以假乱真的像素魔法：DLSS、FSR 与 AI 超分辨率](./06-以假乱真的像素魔法：DLSS、FSR与AI超分辨率.md)*
